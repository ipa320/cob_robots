#!/usr/bin/env python

import roslib; roslib.load_manifest('cob_hardware_test')

import sys
import threading
import time
import unittest

import rospy
import rostest

NAME = 'hztest'

from threading import Thread


class HzTest(unittest.TestCase):
    def __init__(self, *args):
        super(HzTest, self).__init__(*args)
        rospy.init_node(NAME)

       #self.lock = threading.Lock()
       #self.message_received = False

    def setUp(self):
        self.verificationErrors = []
        
        self.errors = []
        # Count of all messages received
        self.msg_count = 0
        # Time of first message received
        self.msg_t0 = -1.0
        # Time of last message received
        self.msg_tn = -1.0
        
    def tearDown(self):
        self.assertEqual([], self.verificationErrors)
        
        
    ## performs two tests of a node, first with /rostime off, then with /rostime on
    def test_hz(self):
        # Fetch parameters
        cob_hardware_test = rospy.get_param('cob_hardware_test')
        
        
        for k, i in cob_hardware_test.iteritems():
            self.lock = threading.Lock()
            
            #Reset for each cycle:
            self.message_received = False
            self.errors = []
            self.msg_count = 0
            self.msg_t0 = -1.0
            self.msg_tn = -1.0
            
            hz = i.get('hz')
            hzerror = i.get('hzerror')
            topic = i.get('topic')
            test_duration = i.get('test_duration')
            wait_time = i.get('wait_time')
            
        
            # We only require hzerror if hz is non-zero
            hzerror = 0.0
            
            if hz != 0.0:
                try:
                    # margin of error allowed
                    #hzerror = float(rospy.get_param('~hzerror'))
                    hzerror = float(i.get('hzerror'))
                except KeyError, e:
                    self.fail('hztest not initialized properly. Parameter [%s] not set. debug[%s] debug[%s]'%(str(e), rospy.get_caller_id(), rospy.resolve_name(e.args[0])))

            # We optionally check each inter-message interval
            try:
                self.check_intervals = bool(rospy.get_param('~check_intervals'))
            except KeyError, e:
                self.check_intervals = False

            # We optionally measure wall clock time
            try:
                self.wall_clock = bool(rospy.get_param('~wall_clock'))
            except KeyError, e:
                self.wall_clock = False

            print """Hz: %s
    Hz Error: %s
    Topic: %s
    Test Duration: %s"""%(hz, hzerror, topic, test_duration)
            
            self._test_hz(hz, hzerror, topic, test_duration, wait_time)
            
    def _test_hz(self, hz, hzerror, topic, test_duration, wait_time):
    
        self.current_test_failed = False
        
        self.assert_(hz >= 0.0, "bad parameter (hz)")
        self.assert_(hzerror >= 0.0, "bad parameter (hzerror)")
        self.assert_(test_duration > 0.0, "bad parameter (test_duration)")
        self.assert_(len(topic), "bad parameter (topic")

        if hz == 0:
            self.min_rate = 0.0
            self.max_rate = 0.0
            self.min_interval = 0.0
            self.max_interval = 0.0
        else:
            self.min_rate = hz - hzerror
            self.max_rate = hz + hzerror
            self.min_interval = 1.0 / self.max_rate
            if self.min_rate <= 0.0:
                self.max_interval = 0.0
            else:
                self.max_interval = 1.0 / self.min_rate

        # Start actual test
        sub = rospy.Subscriber(topic, rospy.AnyMsg, self.callback)
        try: self.assert_(not self.errors, "bad initialization state (errors)")
        except AssertionError, e:
            if not self.current_test_failed:
                self.verificationErrors.append('Topic: %s Error: %s'%(topic, str(e)))
        
        print "Waiting for messages"
        # we have to wait until the first message is received before measuring the rate
        # as time can advance too much before publisher is up
        
        # - give the test 20 seconds to start, may parameterize this in the future
        wallclock_timeout_t = time.time() + wait_time
        while not self.message_received and time.time() < wallclock_timeout_t:
            time.sleep(0.1)
        if hz > 0.:
            try: self.assert_(self.message_received, "no messages before timeout")
            except AssertionError, e:
                if not self.current_test_failed:
                    self.verificationErrors.append('Topic: %s Error: %s'%(topic, str(e)))
                    self.current_test_failed = True
        else:
            try: self.failIf(self.message_received, "message received")
            except AssertionError, e:
                if not self.current_test_failed:
                    self.verificationErrors.append('Topic: %s Error: %s'%(topic, str(e)))
                    self.current_test_failed = True
            
        print "Starting rate measurement"
        if self.wall_clock:
            timeout_t = time.time() + test_duration
            while time.time() < timeout_t:
                time.sleep(0.1)
        else:
            timeout_t = rospy.get_time() + test_duration
            while rospy.get_time() < timeout_t:
                rospy.sleep(0.1)
        print "Done waiting, validating results"
        sub.unregister()

        # Check that we got at least one message
        if hz > 0:
            try: self.assert_(self.msg_count > 0, "no messages received")
            except AssertionError, e:
                if not self.current_test_failed:
                    self.verificationErrors.append('Topic: %s Error: %s'%(topic, str(e)))
                    self.current_test_failed = True
        else:
            try: self.assertEquals(0, self.msg_count)
            except AssertionError, e:
                if not self.current_test_failed:
                    self.verificationErrors.append('Topic: %s Error: %s'%(topic, str(e)))
                    self.current_test_failed = True
        # Check whether inter-message intervals were violated (if we were
        # checking them)
        try: self.assert_(not self.errors, '\n'.join(self.errors))
        except AssertionError, e:
            if not self.current_test_failed:
                self.verificationErrors.append('Topic: %s Error: %s'%(topic, str(e)))
                self.current_test_failed = True

        # If we have a non-zero rate target, make sure that we hit it on
        # average
        if hz > 0.0:
            try:
                self.assert_(self.msg_t0 >= 0.0, "no first message received")
                self.assert_(self.msg_tn >= 0.0, "no last message received")
                dt = self.msg_tn - self.msg_t0
                self.assert_(dt > 0.0, "only one message received")
                rate = ( self.msg_count - 1) / dt
                self.assert_(rate >= self.min_rate, 
                            "average rate (%.3fHz) exceeded minimum (%.3fHz)" %
                            (rate, self.min_rate))
                self.assert_(rate <= self.max_rate, 
                            "average rate (%.3fHz) exceeded maximum (%.3fHz)" %
                            (rate, self.max_rate))
            except AssertionError, e:
                if not self.current_test_failed:
                    self.verificationErrors.append('Topic: %s Error: %s'%(topic, str(e)))
                    self.current_test_failed = True
	    
        
    def callback(self, msg):
        # flag that message has been received
        self.message_received = True         
        try:
            self.lock.acquire()

            if self.wall_clock:
                curr = time.time()
            else:
                curr_rostime = rospy.get_rostime()

                #print "CURR ROSTIME", curr_rostime.to_sec()
                
                if curr_rostime.is_zero():
                    return
                curr = curr_rostime.to_sec()
 
            if self.msg_t0 <= 0.0 or self.msg_t0 > curr:
                self.msg_t0 = curr
                self.msg_count = 1
                last = 0
            else:
                self.msg_count += 1
                last = self.msg_tn

            self.msg_tn = curr

            # If we're instructed to check each inter-message interval, do
            # so
            if self.check_intervals and last > 0:
                interval = curr - last
                if interval < self.min_interval:
                    print >> sys.stderr, "CURR", curr
                    print >> sys.stderr, "LAST", last
                    print >> sys.stderr, "msg_count", self.msg_count
                    print >> sys.stderr, "msg_tn", self.msg_tn
                    self.errors.append(
                        'min_interval exceeded: %s [actual] vs. %s [min]'%\
                        (interval, self.min_interval))
                # If max_interval is <= 0.0, then we have no max
                elif self.max_interval > 0.0 and interval > self.max_interval:
                    self.errors.append(
                        'max_interval exceeded: %s [actual] vs. %s [max]'%\
                        (interval, self.max_interval))

        finally:
            self.lock.release()
    
        
if __name__ == '__main__':
    # A dirty hack to work around an apparent race condition at startup
    # that causes some hztests to fail.  Most evident in the tests of
    # rosstage.
    time.sleep(0.75)
    try:
        rostest.run('rostest', NAME, HzTest, sys.argv)
    except KeyboardInterrupt, e:
        pass
    print "exiting"

        
